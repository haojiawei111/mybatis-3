SQL 执行
   对应 executor 和 cursor 模块。前者对应执行器，后者对应执行结果的游标。


SQL 语句的执行涉及多个组件 ，其中比较重要的是 Executor、StatementHandler、ParameterHandler 和 ResultSetHandler 。

    Executor 主要负责维护一级缓存和二级缓存，并提供事务管理的相关操作，它会将数据库相关操作委托给 StatementHandler完成。
    StatementHandler 首先通过 ParameterHandler 完成 SQL 语句的实参绑定，然后通过 java.sql.Statement 对象执行 SQL 语句并得到结果集，最后通过 ResultSetHandler 完成结果集的映射，得到结果对象并返回。


    正如该包下的分包情况，每个包对应一个功能。
    statement 包，实现向数据库发起 SQL 命令。
    parameter 包，实现设置 PreparedStatement 的占位符参数。
        目前只有一个 ParameterHandler 接口，在 《精尽 MyBatis 源码分析 —— SQL 初始化（下）之 SqlSource》 已经详细解析。
    keygen 包，实现数据库主键生成( 获得 )的功能。
    resultset 包，实现 ResultSet 结果集的处理，将其映射成对应的结果对象。
    result 包，结果的处理，被 resultset 包所调用。可能胖友会好奇为啥会有 resultset 和 result 两个“重叠”的包。答案见 《精尽 MyBatis 源码分析 —— SQL 执行（四）之 ResultSetHandler》 。
    loader 包，实现延迟加载的功能。
    根目录，Executor 接口及其实现类，作为 SQL 执行的核心入口。




每当我们使用 MyBatis 开启一次和数据库的会话，MyBatis 会创建出一个 SqlSession 对象表示一次数据库会话，而每个 SqlSession 都会创建一个 Executor 对象。

在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库，而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。

为了解决这一问题，减少资源的浪费，MyBatis 会在表示会话的SqlSession 对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。😈 注意，这个“简单的缓存”就是一级缓存，且默认开启，无法关闭。

如下图所示，MyBatis 会在一次会话的表示 —— 一个 SqlSession 对象中创建一个本地缓存( localCache )，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。
